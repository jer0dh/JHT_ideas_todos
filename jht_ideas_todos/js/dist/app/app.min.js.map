{"version":3,"sources":["node_modules/browser-pack/_prelude.js","jht_ideas_todos/js/src/app/app.js","app.min.js","node_modules/rivets/dist/rivets.js","node_modules/sightglass/index.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","console","log","rivets","2","Rivets","bindMethod","unbindMethod","_ref","__bind","fn","me","apply","arguments","__slice","slice","__hasProp","hasOwnProperty","__extends","child","parent","ctor","this","constructor","key","prototype","__super__","__indexOf","indexOf","item","options","extensions","public","binders","components","formatters","adapters","prefix","templateDelimiters","rootInterface","preloadData","handler","context","ev","binding","view","models","configure","descriptor","option","value","bind","el","View","init","component","data","scope","document","createElement","innerHTML","template","initialize","window","jQuery","Util","bindEvent","event","unbindEvent","getInputValue","$el","attr","is","val","addEventListener","attachEvent","removeEventListener","detachEvent","_i","_len","_results","type","checked","selected","push","TypeParser","types","primitive","keypath","parse","string","test","isNaN","Number","TextTemplateParser","text","delimiters","index","lastIndex","lastToken","substring","tokens","trim","els","k","v","_base","_j","_len1","_ref1","_ref2","_ref3","_ref4","_ref5","update","publish","sync","unbind","select","traverse","build","buildBinding","bindingRegExp","jquery","Array","concat","RegExp","node","declaration","ctx","dependencies","pipe","pipes","split","shift","bindings","_this","block","childNode","parser","token","nodeType","createTextNode","parentNode","insertBefore","removeChild","_k","_results1","childNodes","sort","b","binder","priority","attribute","attributes","identifier","regexp","nodeName","name","replace","toLowerCase","_bound","ComponentBinding","publishes","model","Binding","getValue","set","eventHandler","formattedValue","parseTarget","observe","setBinder","formatterObservers","args","exec","Function","routine","obj","callback","sightglass","root","observer","target","ai","arg","fi","formatter","id","processedArgs","match","read","dependency","unobserve","reverse","setValue","_super","propertyName","locals","observers","upstreamObservers","camelCase","result","grouped","toUpperCase","_ref6","_ref7","bound","componentView","TextBinding","textContent","innerText","html","show","style","display","hide","enabled","disabled","toString","unchecked","tagName","setAttribute","marker","join","getAttribute","createComment","removeAttribute","nested","nextSibling","unless","function","iterated","collection","modelName","previous","_len2","pop","cloneNode","elClass","className","counter","weakmap","weakReference","_name","Object","defineProperty","callbacks","cleanupWeakReference","ref","keys","pointers","stubFunction","map","original","response","observeMutations","functions","isArray","unobserveMutations","idx","splice","desc","getOwnPropertyDescriptor","get","enumerable","newValue","factory","_","define","amd","3","Observer","objectPath","isObject","realize","error","message","tokenize","interfaces","chr","current","path","charAt","substr","prev","unreached","forEach","next","oldValue","adapter","active","action"],"mappings":"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","file":"app.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Created by jer0dh on 5/11/16.\n */\nvar rivets = require('rivets');\n\n\n //removeIf(production)\nconsole.log('Initializing App');\n //endRemoveIf(production)\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * Created by jer0dh on 5/11/16.\n */\nvar rivets = require('rivets');\n\n//removeIf(production)\nconsole.log('Initializing App');\n//endRemoveIf(production)\n\n},{\"rivets\":2}],2:[function(require,module,exports){\n// Rivets.js\n// version: 0.8.1\n// author: Michael Richards\n// license: MIT\n(function() {\n  var Rivets, bindMethod, unbindMethod, _ref,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Rivets = {\n    options: ['prefix', 'templateDelimiters', 'rootInterface', 'preloadData', 'handler'],\n    extensions: ['binders', 'formatters', 'components', 'adapters'],\n    \"public\": {\n      binders: {},\n      components: {},\n      formatters: {},\n      adapters: {},\n      prefix: 'rv',\n      templateDelimiters: ['{', '}'],\n      rootInterface: '.',\n      preloadData: true,\n      handler: function(context, ev, binding) {\n        return this.call(context, ev, binding.view.models);\n      },\n      configure: function(options) {\n        var descriptor, key, option, value;\n        if (options == null) {\n          options = {};\n        }\n        for (option in options) {\n          value = options[option];\n          if (option === 'binders' || option === 'components' || option === 'formatters' || option === 'adapters') {\n            for (key in value) {\n              descriptor = value[key];\n              Rivets[option][key] = descriptor;\n            }\n          } else {\n            Rivets[\"public\"][option] = value;\n          }\n        }\n      },\n      bind: function(el, models, options) {\n        var view;\n        if (models == null) {\n          models = {};\n        }\n        if (options == null) {\n          options = {};\n        }\n        view = new Rivets.View(el, models, options);\n        view.bind();\n        return view;\n      },\n      init: function(component, el, data) {\n        var scope, view;\n        if (data == null) {\n          data = {};\n        }\n        if (el == null) {\n          el = document.createElement('div');\n        }\n        component = Rivets[\"public\"].components[component];\n        el.innerHTML = component.template.call(this, el);\n        scope = component.initialize.call(this, el, data);\n        view = new Rivets.View(el, scope);\n        view.bind();\n        return view;\n      }\n    }\n  };\n\n  if (window['jQuery'] || window['$']) {\n    _ref = 'on' in jQuery.prototype ? ['on', 'off'] : ['bind', 'unbind'], bindMethod = _ref[0], unbindMethod = _ref[1];\n    Rivets.Util = {\n      bindEvent: function(el, event, handler) {\n        return jQuery(el)[bindMethod](event, handler);\n      },\n      unbindEvent: function(el, event, handler) {\n        return jQuery(el)[unbindMethod](event, handler);\n      },\n      getInputValue: function(el) {\n        var $el;\n        $el = jQuery(el);\n        if ($el.attr('type') === 'checkbox') {\n          return $el.is(':checked');\n        } else {\n          return $el.val();\n        }\n      }\n    };\n  } else {\n    Rivets.Util = {\n      bindEvent: (function() {\n        if ('addEventListener' in window) {\n          return function(el, event, handler) {\n            return el.addEventListener(event, handler, false);\n          };\n        }\n        return function(el, event, handler) {\n          return el.attachEvent('on' + event, handler);\n        };\n      })(),\n      unbindEvent: (function() {\n        if ('removeEventListener' in window) {\n          return function(el, event, handler) {\n            return el.removeEventListener(event, handler, false);\n          };\n        }\n        return function(el, event, handler) {\n          return el.detachEvent('on' + event, handler);\n        };\n      })(),\n      getInputValue: function(el) {\n        var o, _i, _len, _results;\n        if (el.type === 'checkbox') {\n          return el.checked;\n        } else if (el.type === 'select-multiple') {\n          _results = [];\n          for (_i = 0, _len = el.length; _i < _len; _i++) {\n            o = el[_i];\n            if (o.selected) {\n              _results.push(o.value);\n            }\n          }\n          return _results;\n        } else {\n          return el.value;\n        }\n      }\n    };\n  }\n\n  Rivets.TypeParser = (function() {\n    function TypeParser() {}\n\n    TypeParser.types = {\n      primitive: 0,\n      keypath: 1\n    };\n\n    TypeParser.parse = function(string) {\n      if (/^'.*'$|^\".*\"$/.test(string)) {\n        return {\n          type: this.types.primitive,\n          value: string.slice(1, -1)\n        };\n      } else if (string === 'true') {\n        return {\n          type: this.types.primitive,\n          value: true\n        };\n      } else if (string === 'false') {\n        return {\n          type: this.types.primitive,\n          value: false\n        };\n      } else if (string === 'null') {\n        return {\n          type: this.types.primitive,\n          value: null\n        };\n      } else if (string === 'undefined') {\n        return {\n          type: this.types.primitive,\n          value: void 0\n        };\n      } else if (isNaN(Number(string)) === false) {\n        return {\n          type: this.types.primitive,\n          value: Number(string)\n        };\n      } else {\n        return {\n          type: this.types.keypath,\n          value: string\n        };\n      }\n    };\n\n    return TypeParser;\n\n  })();\n\n  Rivets.TextTemplateParser = (function() {\n    function TextTemplateParser() {}\n\n    TextTemplateParser.types = {\n      text: 0,\n      binding: 1\n    };\n\n    TextTemplateParser.parse = function(template, delimiters) {\n      var index, lastIndex, lastToken, length, substring, tokens, value;\n      tokens = [];\n      length = template.length;\n      index = 0;\n      lastIndex = 0;\n      while (lastIndex < length) {\n        index = template.indexOf(delimiters[0], lastIndex);\n        if (index < 0) {\n          tokens.push({\n            type: this.types.text,\n            value: template.slice(lastIndex)\n          });\n          break;\n        } else {\n          if (index > 0 && lastIndex < index) {\n            tokens.push({\n              type: this.types.text,\n              value: template.slice(lastIndex, index)\n            });\n          }\n          lastIndex = index + delimiters[0].length;\n          index = template.indexOf(delimiters[1], lastIndex);\n          if (index < 0) {\n            substring = template.slice(lastIndex - delimiters[1].length);\n            lastToken = tokens[tokens.length - 1];\n            if ((lastToken != null ? lastToken.type : void 0) === this.types.text) {\n              lastToken.value += substring;\n            } else {\n              tokens.push({\n                type: this.types.text,\n                value: substring\n              });\n            }\n            break;\n          }\n          value = template.slice(lastIndex, index).trim();\n          tokens.push({\n            type: this.types.binding,\n            value: value\n          });\n          lastIndex = index + delimiters[1].length;\n        }\n      }\n      return tokens;\n    };\n\n    return TextTemplateParser;\n\n  })();\n\n  Rivets.View = (function() {\n    function View(els, models, options) {\n      var k, option, v, _base, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5;\n      this.els = els;\n      this.models = models;\n      if (options == null) {\n        options = {};\n      }\n      this.update = __bind(this.update, this);\n      this.publish = __bind(this.publish, this);\n      this.sync = __bind(this.sync, this);\n      this.unbind = __bind(this.unbind, this);\n      this.bind = __bind(this.bind, this);\n      this.select = __bind(this.select, this);\n      this.traverse = __bind(this.traverse, this);\n      this.build = __bind(this.build, this);\n      this.buildBinding = __bind(this.buildBinding, this);\n      this.bindingRegExp = __bind(this.bindingRegExp, this);\n      this.options = __bind(this.options, this);\n      if (!(this.els.jquery || this.els instanceof Array)) {\n        this.els = [this.els];\n      }\n      _ref1 = Rivets.extensions;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        option = _ref1[_i];\n        this[option] = {};\n        if (options[option]) {\n          _ref2 = options[option];\n          for (k in _ref2) {\n            v = _ref2[k];\n            this[option][k] = v;\n          }\n        }\n        _ref3 = Rivets[\"public\"][option];\n        for (k in _ref3) {\n          v = _ref3[k];\n          if ((_base = this[option])[k] == null) {\n            _base[k] = v;\n          }\n        }\n      }\n      _ref4 = Rivets.options;\n      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {\n        option = _ref4[_j];\n        this[option] = (_ref5 = options[option]) != null ? _ref5 : Rivets[\"public\"][option];\n      }\n      this.build();\n    }\n\n    View.prototype.options = function() {\n      var option, options, _i, _len, _ref1;\n      options = {};\n      _ref1 = Rivets.extensions.concat(Rivets.options);\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        option = _ref1[_i];\n        options[option] = this[option];\n      }\n      return options;\n    };\n\n    View.prototype.bindingRegExp = function() {\n      return new RegExp(\"^\" + this.prefix + \"-\");\n    };\n\n    View.prototype.buildBinding = function(binding, node, type, declaration) {\n      var context, ctx, dependencies, keypath, options, pipe, pipes;\n      options = {};\n      pipes = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = declaration.split('|');\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          pipe = _ref1[_i];\n          _results.push(pipe.trim());\n        }\n        return _results;\n      })();\n      context = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = pipes.shift().split('<');\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          ctx = _ref1[_i];\n          _results.push(ctx.trim());\n        }\n        return _results;\n      })();\n      keypath = context.shift();\n      options.formatters = pipes;\n      if (dependencies = context.shift()) {\n        options.dependencies = dependencies.split(/\\s+/);\n      }\n      return this.bindings.push(new Rivets[binding](this, node, type, keypath, options));\n    };\n\n    View.prototype.build = function() {\n      var el, parse, _i, _len, _ref1;\n      this.bindings = [];\n      parse = (function(_this) {\n        return function(node) {\n          var block, childNode, delimiters, n, parser, text, token, tokens, _i, _j, _len, _len1, _ref1, _results;\n          if (node.nodeType === 3) {\n            parser = Rivets.TextTemplateParser;\n            if (delimiters = _this.templateDelimiters) {\n              if ((tokens = parser.parse(node.data, delimiters)).length) {\n                if (!(tokens.length === 1 && tokens[0].type === parser.types.text)) {\n                  for (_i = 0, _len = tokens.length; _i < _len; _i++) {\n                    token = tokens[_i];\n                    text = document.createTextNode(token.value);\n                    node.parentNode.insertBefore(text, node);\n                    if (token.type === 1) {\n                      _this.buildBinding('TextBinding', text, null, token.value);\n                    }\n                  }\n                  node.parentNode.removeChild(node);\n                }\n              }\n            }\n          } else if (node.nodeType === 1) {\n            block = _this.traverse(node);\n          }\n          if (!block) {\n            _ref1 = (function() {\n              var _k, _len1, _ref1, _results1;\n              _ref1 = node.childNodes;\n              _results1 = [];\n              for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {\n                n = _ref1[_k];\n                _results1.push(n);\n              }\n              return _results1;\n            })();\n            _results = [];\n            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n              childNode = _ref1[_j];\n              _results.push(parse(childNode));\n            }\n            return _results;\n          }\n        };\n      })(this);\n      _ref1 = this.els;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        el = _ref1[_i];\n        parse(el);\n      }\n      this.bindings.sort(function(a, b) {\n        var _ref2, _ref3;\n        return (((_ref2 = b.binder) != null ? _ref2.priority : void 0) || 0) - (((_ref3 = a.binder) != null ? _ref3.priority : void 0) || 0);\n      });\n    };\n\n    View.prototype.traverse = function(node) {\n      var attribute, attributes, binder, bindingRegExp, block, identifier, regexp, type, value, _i, _j, _len, _len1, _ref1, _ref2, _ref3;\n      bindingRegExp = this.bindingRegExp();\n      block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE';\n      _ref1 = node.attributes;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        attribute = _ref1[_i];\n        if (bindingRegExp.test(attribute.name)) {\n          type = attribute.name.replace(bindingRegExp, '');\n          if (!(binder = this.binders[type])) {\n            _ref2 = this.binders;\n            for (identifier in _ref2) {\n              value = _ref2[identifier];\n              if (identifier !== '*' && identifier.indexOf('*') !== -1) {\n                regexp = new RegExp(\"^\" + (identifier.replace(/\\*/g, '.+')) + \"$\");\n                if (regexp.test(type)) {\n                  binder = value;\n                }\n              }\n            }\n          }\n          binder || (binder = this.binders['*']);\n          if (binder.block) {\n            block = true;\n            attributes = [attribute];\n          }\n        }\n      }\n      _ref3 = attributes || node.attributes;\n      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {\n        attribute = _ref3[_j];\n        if (bindingRegExp.test(attribute.name)) {\n          type = attribute.name.replace(bindingRegExp, '');\n          this.buildBinding('Binding', node, type, attribute.value);\n        }\n      }\n      if (!block) {\n        type = node.nodeName.toLowerCase();\n        if (this.components[type] && !node._bound) {\n          this.bindings.push(new Rivets.ComponentBinding(this, node, type));\n          block = true;\n        }\n      }\n      return block;\n    };\n\n    View.prototype.select = function(fn) {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        if (fn(binding)) {\n          _results.push(binding);\n        }\n      }\n      return _results;\n    };\n\n    View.prototype.bind = function() {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(binding.bind());\n      }\n      return _results;\n    };\n\n    View.prototype.unbind = function() {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(binding.unbind());\n      }\n      return _results;\n    };\n\n    View.prototype.sync = function() {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(typeof binding.sync === \"function\" ? binding.sync() : void 0);\n      }\n      return _results;\n    };\n\n    View.prototype.publish = function() {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.select(function(b) {\n        var _ref1;\n        return (_ref1 = b.binder) != null ? _ref1.publishes : void 0;\n      });\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(binding.publish());\n      }\n      return _results;\n    };\n\n    View.prototype.update = function(models) {\n      var binding, key, model, _i, _len, _ref1, _results;\n      if (models == null) {\n        models = {};\n      }\n      for (key in models) {\n        model = models[key];\n        this.models[key] = model;\n      }\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(typeof binding.update === \"function\" ? binding.update(models) : void 0);\n      }\n      return _results;\n    };\n\n    return View;\n\n  })();\n\n  Rivets.Binding = (function() {\n    function Binding(view, el, type, keypath, options) {\n      this.view = view;\n      this.el = el;\n      this.type = type;\n      this.keypath = keypath;\n      this.options = options != null ? options : {};\n      this.getValue = __bind(this.getValue, this);\n      this.update = __bind(this.update, this);\n      this.unbind = __bind(this.unbind, this);\n      this.bind = __bind(this.bind, this);\n      this.publish = __bind(this.publish, this);\n      this.sync = __bind(this.sync, this);\n      this.set = __bind(this.set, this);\n      this.eventHandler = __bind(this.eventHandler, this);\n      this.formattedValue = __bind(this.formattedValue, this);\n      this.parseTarget = __bind(this.parseTarget, this);\n      this.observe = __bind(this.observe, this);\n      this.setBinder = __bind(this.setBinder, this);\n      this.formatters = this.options.formatters || [];\n      this.dependencies = [];\n      this.formatterObservers = {};\n      this.model = void 0;\n      this.setBinder();\n    }\n\n    Binding.prototype.setBinder = function() {\n      var identifier, regexp, value, _ref1;\n      if (!(this.binder = this.view.binders[this.type])) {\n        _ref1 = this.view.binders;\n        for (identifier in _ref1) {\n          value = _ref1[identifier];\n          if (identifier !== '*' && identifier.indexOf('*') !== -1) {\n            regexp = new RegExp(\"^\" + (identifier.replace(/\\*/g, '.+')) + \"$\");\n            if (regexp.test(this.type)) {\n              this.binder = value;\n              this.args = new RegExp(\"^\" + (identifier.replace(/\\*/g, '(.+)')) + \"$\").exec(this.type);\n              this.args.shift();\n            }\n          }\n        }\n      }\n      this.binder || (this.binder = this.view.binders['*']);\n      if (this.binder instanceof Function) {\n        return this.binder = {\n          routine: this.binder\n        };\n      }\n    };\n\n    Binding.prototype.observe = function(obj, keypath, callback) {\n      return Rivets.sightglass(obj, keypath, callback, {\n        root: this.view.rootInterface,\n        adapters: this.view.adapters\n      });\n    };\n\n    Binding.prototype.parseTarget = function() {\n      var token;\n      token = Rivets.TypeParser.parse(this.keypath);\n      if (token.type === 0) {\n        return this.value = token.value;\n      } else {\n        this.observer = this.observe(this.view.models, this.keypath, this.sync);\n        return this.model = this.observer.target;\n      }\n    };\n\n    Binding.prototype.formattedValue = function(value) {\n      var ai, arg, args, fi, formatter, id, observer, processedArgs, _base, _i, _j, _len, _len1, _ref1;\n      _ref1 = this.formatters;\n      for (fi = _i = 0, _len = _ref1.length; _i < _len; fi = ++_i) {\n        formatter = _ref1[fi];\n        args = formatter.match(/[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g);\n        id = args.shift();\n        formatter = this.view.formatters[id];\n        args = (function() {\n          var _j, _len1, _results;\n          _results = [];\n          for (_j = 0, _len1 = args.length; _j < _len1; _j++) {\n            arg = args[_j];\n            _results.push(Rivets.TypeParser.parse(arg));\n          }\n          return _results;\n        })();\n        processedArgs = [];\n        for (ai = _j = 0, _len1 = args.length; _j < _len1; ai = ++_j) {\n          arg = args[ai];\n          processedArgs.push(arg.type === 0 ? arg.value : ((_base = this.formatterObservers)[fi] || (_base[fi] = {}), !(observer = this.formatterObservers[fi][ai]) ? (observer = this.observe(this.view.models, arg.value, this.sync), this.formatterObservers[fi][ai] = observer) : void 0, observer.value()));\n        }\n        if ((formatter != null ? formatter.read : void 0) instanceof Function) {\n          value = formatter.read.apply(formatter, [value].concat(__slice.call(processedArgs)));\n        } else if (formatter instanceof Function) {\n          value = formatter.apply(null, [value].concat(__slice.call(processedArgs)));\n        }\n      }\n      return value;\n    };\n\n    Binding.prototype.eventHandler = function(fn) {\n      var binding, handler;\n      handler = (binding = this).view.handler;\n      return function(ev) {\n        return handler.call(fn, this, ev, binding);\n      };\n    };\n\n    Binding.prototype.set = function(value) {\n      var _ref1;\n      value = value instanceof Function && !this.binder[\"function\"] ? this.formattedValue(value.call(this.model)) : this.formattedValue(value);\n      return (_ref1 = this.binder.routine) != null ? _ref1.call(this, this.el, value) : void 0;\n    };\n\n    Binding.prototype.sync = function() {\n      var dependency, observer;\n      return this.set((function() {\n        var _i, _j, _len, _len1, _ref1, _ref2, _ref3;\n        if (this.observer) {\n          if (this.model !== this.observer.target) {\n            _ref1 = this.dependencies;\n            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n              observer = _ref1[_i];\n              observer.unobserve();\n            }\n            this.dependencies = [];\n            if (((this.model = this.observer.target) != null) && ((_ref2 = this.options.dependencies) != null ? _ref2.length : void 0)) {\n              _ref3 = this.options.dependencies;\n              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {\n                dependency = _ref3[_j];\n                observer = this.observe(this.model, dependency, this.sync);\n                this.dependencies.push(observer);\n              }\n            }\n          }\n          return this.observer.value();\n        } else {\n          return this.value;\n        }\n      }).call(this));\n    };\n\n    Binding.prototype.publish = function() {\n      var args, formatter, id, value, _i, _len, _ref1, _ref2, _ref3;\n      if (this.observer) {\n        value = this.getValue(this.el);\n        _ref1 = this.formatters.slice(0).reverse();\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          formatter = _ref1[_i];\n          args = formatter.split(/\\s+/);\n          id = args.shift();\n          if ((_ref2 = this.view.formatters[id]) != null ? _ref2.publish : void 0) {\n            value = (_ref3 = this.view.formatters[id]).publish.apply(_ref3, [value].concat(__slice.call(args)));\n          }\n        }\n        return this.observer.setValue(value);\n      }\n    };\n\n    Binding.prototype.bind = function() {\n      var dependency, observer, _i, _len, _ref1, _ref2, _ref3;\n      this.parseTarget();\n      if ((_ref1 = this.binder.bind) != null) {\n        _ref1.call(this, this.el);\n      }\n      if ((this.model != null) && ((_ref2 = this.options.dependencies) != null ? _ref2.length : void 0)) {\n        _ref3 = this.options.dependencies;\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          dependency = _ref3[_i];\n          observer = this.observe(this.model, dependency, this.sync);\n          this.dependencies.push(observer);\n        }\n      }\n      if (this.view.preloadData) {\n        return this.sync();\n      }\n    };\n\n    Binding.prototype.unbind = function() {\n      var ai, args, fi, observer, _i, _len, _ref1, _ref2, _ref3, _ref4;\n      if ((_ref1 = this.binder.unbind) != null) {\n        _ref1.call(this, this.el);\n      }\n      if ((_ref2 = this.observer) != null) {\n        _ref2.unobserve();\n      }\n      _ref3 = this.dependencies;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        observer = _ref3[_i];\n        observer.unobserve();\n      }\n      this.dependencies = [];\n      _ref4 = this.formatterObservers;\n      for (fi in _ref4) {\n        args = _ref4[fi];\n        for (ai in args) {\n          observer = args[ai];\n          observer.unobserve();\n        }\n      }\n      return this.formatterObservers = {};\n    };\n\n    Binding.prototype.update = function(models) {\n      var _ref1, _ref2;\n      if (models == null) {\n        models = {};\n      }\n      this.model = (_ref1 = this.observer) != null ? _ref1.target : void 0;\n      return (_ref2 = this.binder.update) != null ? _ref2.call(this, models) : void 0;\n    };\n\n    Binding.prototype.getValue = function(el) {\n      if (this.binder && (this.binder.getValue != null)) {\n        return this.binder.getValue.call(this, el);\n      } else {\n        return Rivets.Util.getInputValue(el);\n      }\n    };\n\n    return Binding;\n\n  })();\n\n  Rivets.ComponentBinding = (function(_super) {\n    __extends(ComponentBinding, _super);\n\n    function ComponentBinding(view, el, type) {\n      var attribute, bindingRegExp, propertyName, _i, _len, _ref1, _ref2;\n      this.view = view;\n      this.el = el;\n      this.type = type;\n      this.unbind = __bind(this.unbind, this);\n      this.bind = __bind(this.bind, this);\n      this.locals = __bind(this.locals, this);\n      this.component = this.view.components[this.type];\n      this[\"static\"] = {};\n      this.observers = {};\n      this.upstreamObservers = {};\n      bindingRegExp = view.bindingRegExp();\n      _ref1 = this.el.attributes || [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        attribute = _ref1[_i];\n        if (!bindingRegExp.test(attribute.name)) {\n          propertyName = this.camelCase(attribute.name);\n          if (__indexOf.call((_ref2 = this.component[\"static\"]) != null ? _ref2 : [], propertyName) >= 0) {\n            this[\"static\"][propertyName] = attribute.value;\n          } else {\n            this.observers[propertyName] = attribute.value;\n          }\n        }\n      }\n    }\n\n    ComponentBinding.prototype.sync = function() {};\n\n    ComponentBinding.prototype.update = function() {};\n\n    ComponentBinding.prototype.publish = function() {};\n\n    ComponentBinding.prototype.locals = function() {\n      var key, observer, result, value, _ref1, _ref2;\n      result = {};\n      _ref1 = this[\"static\"];\n      for (key in _ref1) {\n        value = _ref1[key];\n        result[key] = value;\n      }\n      _ref2 = this.observers;\n      for (key in _ref2) {\n        observer = _ref2[key];\n        result[key] = observer.value();\n      }\n      return result;\n    };\n\n    ComponentBinding.prototype.camelCase = function(string) {\n      return string.replace(/-([a-z])/g, function(grouped) {\n        return grouped[1].toUpperCase();\n      });\n    };\n\n    ComponentBinding.prototype.bind = function() {\n      var k, key, keypath, observer, option, options, scope, v, _base, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _results;\n      if (!this.bound) {\n        _ref1 = this.observers;\n        for (key in _ref1) {\n          keypath = _ref1[key];\n          this.observers[key] = this.observe(this.view.models, keypath, ((function(_this) {\n            return function(key) {\n              return function() {\n                return _this.componentView.models[key] = _this.observers[key].value();\n              };\n            };\n          })(this)).call(this, key));\n        }\n        this.bound = true;\n      }\n      if (this.componentView != null) {\n        return this.componentView.bind();\n      } else {\n        this.el.innerHTML = this.component.template.call(this);\n        scope = this.component.initialize.call(this, this.el, this.locals());\n        this.el._bound = true;\n        options = {};\n        _ref2 = Rivets.extensions;\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          option = _ref2[_i];\n          options[option] = {};\n          if (this.component[option]) {\n            _ref3 = this.component[option];\n            for (k in _ref3) {\n              v = _ref3[k];\n              options[option][k] = v;\n            }\n          }\n          _ref4 = this.view[option];\n          for (k in _ref4) {\n            v = _ref4[k];\n            if ((_base = options[option])[k] == null) {\n              _base[k] = v;\n            }\n          }\n        }\n        _ref5 = Rivets.options;\n        for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {\n          option = _ref5[_j];\n          options[option] = (_ref6 = this.component[option]) != null ? _ref6 : this.view[option];\n        }\n        this.componentView = new Rivets.View(this.el, scope, options);\n        this.componentView.bind();\n        _ref7 = this.observers;\n        _results = [];\n        for (key in _ref7) {\n          observer = _ref7[key];\n          _results.push(this.upstreamObservers[key] = this.observe(this.componentView.models, key, ((function(_this) {\n            return function(key, observer) {\n              return function() {\n                return observer.setValue(_this.componentView.models[key]);\n              };\n            };\n          })(this)).call(this, key, observer)));\n        }\n        return _results;\n      }\n    };\n\n    ComponentBinding.prototype.unbind = function() {\n      var key, observer, _ref1, _ref2, _ref3;\n      _ref1 = this.upstreamObservers;\n      for (key in _ref1) {\n        observer = _ref1[key];\n        observer.unobserve();\n      }\n      _ref2 = this.observers;\n      for (key in _ref2) {\n        observer = _ref2[key];\n        observer.unobserve();\n      }\n      return (_ref3 = this.componentView) != null ? _ref3.unbind.call(this) : void 0;\n    };\n\n    return ComponentBinding;\n\n  })(Rivets.Binding);\n\n  Rivets.TextBinding = (function(_super) {\n    __extends(TextBinding, _super);\n\n    function TextBinding(view, el, type, keypath, options) {\n      this.view = view;\n      this.el = el;\n      this.type = type;\n      this.keypath = keypath;\n      this.options = options != null ? options : {};\n      this.sync = __bind(this.sync, this);\n      this.formatters = this.options.formatters || [];\n      this.dependencies = [];\n      this.formatterObservers = {};\n    }\n\n    TextBinding.prototype.binder = {\n      routine: function(node, value) {\n        return node.data = value != null ? value : '';\n      }\n    };\n\n    TextBinding.prototype.sync = function() {\n      return TextBinding.__super__.sync.apply(this, arguments);\n    };\n\n    return TextBinding;\n\n  })(Rivets.Binding);\n\n  Rivets[\"public\"].binders.text = function(el, value) {\n    if (el.textContent != null) {\n      return el.textContent = value != null ? value : '';\n    } else {\n      return el.innerText = value != null ? value : '';\n    }\n  };\n\n  Rivets[\"public\"].binders.html = function(el, value) {\n    return el.innerHTML = value != null ? value : '';\n  };\n\n  Rivets[\"public\"].binders.show = function(el, value) {\n    return el.style.display = value ? '' : 'none';\n  };\n\n  Rivets[\"public\"].binders.hide = function(el, value) {\n    return el.style.display = value ? 'none' : '';\n  };\n\n  Rivets[\"public\"].binders.enabled = function(el, value) {\n    return el.disabled = !value;\n  };\n\n  Rivets[\"public\"].binders.disabled = function(el, value) {\n    return el.disabled = !!value;\n  };\n\n  Rivets[\"public\"].binders.checked = {\n    publishes: true,\n    priority: 2000,\n    bind: function(el) {\n      return Rivets.Util.bindEvent(el, 'change', this.publish);\n    },\n    unbind: function(el) {\n      return Rivets.Util.unbindEvent(el, 'change', this.publish);\n    },\n    routine: function(el, value) {\n      var _ref1;\n      if (el.type === 'radio') {\n        return el.checked = ((_ref1 = el.value) != null ? _ref1.toString() : void 0) === (value != null ? value.toString() : void 0);\n      } else {\n        return el.checked = !!value;\n      }\n    }\n  };\n\n  Rivets[\"public\"].binders.unchecked = {\n    publishes: true,\n    priority: 2000,\n    bind: function(el) {\n      return Rivets.Util.bindEvent(el, 'change', this.publish);\n    },\n    unbind: function(el) {\n      return Rivets.Util.unbindEvent(el, 'change', this.publish);\n    },\n    routine: function(el, value) {\n      var _ref1;\n      if (el.type === 'radio') {\n        return el.checked = ((_ref1 = el.value) != null ? _ref1.toString() : void 0) !== (value != null ? value.toString() : void 0);\n      } else {\n        return el.checked = !value;\n      }\n    }\n  };\n\n  Rivets[\"public\"].binders.value = {\n    publishes: true,\n    priority: 3000,\n    bind: function(el) {\n      if (!(el.tagName === 'INPUT' && el.type === 'radio')) {\n        this.event = el.tagName === 'SELECT' ? 'change' : 'input';\n        return Rivets.Util.bindEvent(el, this.event, this.publish);\n      }\n    },\n    unbind: function(el) {\n      if (!(el.tagName === 'INPUT' && el.type === 'radio')) {\n        return Rivets.Util.unbindEvent(el, this.event, this.publish);\n      }\n    },\n    routine: function(el, value) {\n      var o, _i, _len, _ref1, _ref2, _ref3, _results;\n      if (el.tagName === 'INPUT' && el.type === 'radio') {\n        return el.setAttribute('value', value);\n      } else if (window.jQuery != null) {\n        el = jQuery(el);\n        if ((value != null ? value.toString() : void 0) !== ((_ref1 = el.val()) != null ? _ref1.toString() : void 0)) {\n          return el.val(value != null ? value : '');\n        }\n      } else {\n        if (el.type === 'select-multiple') {\n          if (value != null) {\n            _results = [];\n            for (_i = 0, _len = el.length; _i < _len; _i++) {\n              o = el[_i];\n              _results.push(o.selected = (_ref2 = o.value, __indexOf.call(value, _ref2) >= 0));\n            }\n            return _results;\n          }\n        } else if ((value != null ? value.toString() : void 0) !== ((_ref3 = el.value) != null ? _ref3.toString() : void 0)) {\n          return el.value = value != null ? value : '';\n        }\n      }\n    }\n  };\n\n  Rivets[\"public\"].binders[\"if\"] = {\n    block: true,\n    priority: 4000,\n    bind: function(el) {\n      var attr, declaration;\n      if (this.marker == null) {\n        attr = [this.view.prefix, this.type].join('-').replace('--', '-');\n        declaration = el.getAttribute(attr);\n        this.marker = document.createComment(\" rivets: \" + this.type + \" \" + declaration + \" \");\n        this.bound = false;\n        el.removeAttribute(attr);\n        el.parentNode.insertBefore(this.marker, el);\n        return el.parentNode.removeChild(el);\n      }\n    },\n    unbind: function() {\n      var _ref1;\n      return (_ref1 = this.nested) != null ? _ref1.unbind() : void 0;\n    },\n    routine: function(el, value) {\n      var key, model, models, _ref1;\n      if (!!value === !this.bound) {\n        if (value) {\n          models = {};\n          _ref1 = this.view.models;\n          for (key in _ref1) {\n            model = _ref1[key];\n            models[key] = model;\n          }\n          (this.nested || (this.nested = new Rivets.View(el, models, this.view.options()))).bind();\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling);\n          return this.bound = true;\n        } else {\n          el.parentNode.removeChild(el);\n          this.nested.unbind();\n          return this.bound = false;\n        }\n      }\n    },\n    update: function(models) {\n      var _ref1;\n      return (_ref1 = this.nested) != null ? _ref1.update(models) : void 0;\n    }\n  };\n\n  Rivets[\"public\"].binders.unless = {\n    block: true,\n    priority: 4000,\n    bind: function(el) {\n      return Rivets[\"public\"].binders[\"if\"].bind.call(this, el);\n    },\n    unbind: function() {\n      return Rivets[\"public\"].binders[\"if\"].unbind.call(this);\n    },\n    routine: function(el, value) {\n      return Rivets[\"public\"].binders[\"if\"].routine.call(this, el, !value);\n    },\n    update: function(models) {\n      return Rivets[\"public\"].binders[\"if\"].update.call(this, models);\n    }\n  };\n\n  Rivets[\"public\"].binders['on-*'] = {\n    \"function\": true,\n    priority: 1000,\n    unbind: function(el) {\n      if (this.handler) {\n        return Rivets.Util.unbindEvent(el, this.args[0], this.handler);\n      }\n    },\n    routine: function(el, value) {\n      if (this.handler) {\n        Rivets.Util.unbindEvent(el, this.args[0], this.handler);\n      }\n      return Rivets.Util.bindEvent(el, this.args[0], this.handler = this.eventHandler(value));\n    }\n  };\n\n  Rivets[\"public\"].binders['each-*'] = {\n    block: true,\n    priority: 4000,\n    bind: function(el) {\n      var attr, view, _i, _len, _ref1;\n      if (this.marker == null) {\n        attr = [this.view.prefix, this.type].join('-').replace('--', '-');\n        this.marker = document.createComment(\" rivets: \" + this.type + \" \");\n        this.iterated = [];\n        el.removeAttribute(attr);\n        el.parentNode.insertBefore(this.marker, el);\n        el.parentNode.removeChild(el);\n      } else {\n        _ref1 = this.iterated;\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          view = _ref1[_i];\n          view.bind();\n        }\n      }\n    },\n    unbind: function(el) {\n      var view, _i, _len, _ref1, _results;\n      if (this.iterated != null) {\n        _ref1 = this.iterated;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          view = _ref1[_i];\n          _results.push(view.unbind());\n        }\n        return _results;\n      }\n    },\n    routine: function(el, collection) {\n      var binding, data, i, index, key, model, modelName, options, previous, template, view, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;\n      modelName = this.args[0];\n      collection = collection || [];\n      if (this.iterated.length > collection.length) {\n        _ref1 = Array(this.iterated.length - collection.length);\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          i = _ref1[_i];\n          view = this.iterated.pop();\n          view.unbind();\n          this.marker.parentNode.removeChild(view.els[0]);\n        }\n      }\n      for (index = _j = 0, _len1 = collection.length; _j < _len1; index = ++_j) {\n        model = collection[index];\n        data = {\n          index: index\n        };\n        data[modelName] = model;\n        if (this.iterated[index] == null) {\n          _ref2 = this.view.models;\n          for (key in _ref2) {\n            model = _ref2[key];\n            if (data[key] == null) {\n              data[key] = model;\n            }\n          }\n          previous = this.iterated.length ? this.iterated[this.iterated.length - 1].els[0] : this.marker;\n          options = this.view.options();\n          options.preloadData = true;\n          template = el.cloneNode(true);\n          view = new Rivets.View(template, data, options);\n          view.bind();\n          this.iterated.push(view);\n          this.marker.parentNode.insertBefore(template, previous.nextSibling);\n        } else if (this.iterated[index].models[modelName] !== model) {\n          this.iterated[index].update(data);\n        }\n      }\n      if (el.nodeName === 'OPTION') {\n        _ref3 = this.view.bindings;\n        _results = [];\n        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n          binding = _ref3[_k];\n          if (binding.el === this.marker.parentNode && binding.type === 'value') {\n            _results.push(binding.sync());\n          } else {\n            _results.push(void 0);\n          }\n        }\n        return _results;\n      }\n    },\n    update: function(models) {\n      var data, key, model, view, _i, _len, _ref1, _results;\n      data = {};\n      for (key in models) {\n        model = models[key];\n        if (key !== this.args[0]) {\n          data[key] = model;\n        }\n      }\n      _ref1 = this.iterated;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        view = _ref1[_i];\n        _results.push(view.update(data));\n      }\n      return _results;\n    }\n  };\n\n  Rivets[\"public\"].binders['class-*'] = function(el, value) {\n    var elClass;\n    elClass = \" \" + el.className + \" \";\n    if (!value === (elClass.indexOf(\" \" + this.args[0] + \" \") !== -1)) {\n      return el.className = value ? \"\" + el.className + \" \" + this.args[0] : elClass.replace(\" \" + this.args[0] + \" \", ' ').trim();\n    }\n  };\n\n  Rivets[\"public\"].binders['*'] = function(el, value) {\n    if (value != null) {\n      return el.setAttribute(this.type, value);\n    } else {\n      return el.removeAttribute(this.type);\n    }\n  };\n\n  Rivets[\"public\"].adapters['.'] = {\n    id: '_rv',\n    counter: 0,\n    weakmap: {},\n    weakReference: function(obj) {\n      var id, _base, _name;\n      if (!obj.hasOwnProperty(this.id)) {\n        id = this.counter++;\n        Object.defineProperty(obj, this.id, {\n          value: id\n        });\n      }\n      return (_base = this.weakmap)[_name = obj[this.id]] || (_base[_name] = {\n        callbacks: {}\n      });\n    },\n    cleanupWeakReference: function(ref, id) {\n      if (!Object.keys(ref.callbacks).length) {\n        if (!(ref.pointers && Object.keys(ref.pointers).length)) {\n          return delete this.weakmap[id];\n        }\n      }\n    },\n    stubFunction: function(obj, fn) {\n      var map, original, weakmap;\n      original = obj[fn];\n      map = this.weakReference(obj);\n      weakmap = this.weakmap;\n      return obj[fn] = function() {\n        var callback, k, r, response, _i, _len, _ref1, _ref2, _ref3, _ref4;\n        response = original.apply(obj, arguments);\n        _ref1 = map.pointers;\n        for (r in _ref1) {\n          k = _ref1[r];\n          _ref4 = (_ref2 = (_ref3 = weakmap[r]) != null ? _ref3.callbacks[k] : void 0) != null ? _ref2 : [];\n          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n            callback = _ref4[_i];\n            callback();\n          }\n        }\n        return response;\n      };\n    },\n    observeMutations: function(obj, ref, keypath) {\n      var fn, functions, map, _base, _i, _len;\n      if (Array.isArray(obj)) {\n        map = this.weakReference(obj);\n        if (map.pointers == null) {\n          map.pointers = {};\n          functions = ['push', 'pop', 'shift', 'unshift', 'sort', 'reverse', 'splice'];\n          for (_i = 0, _len = functions.length; _i < _len; _i++) {\n            fn = functions[_i];\n            this.stubFunction(obj, fn);\n          }\n        }\n        if ((_base = map.pointers)[ref] == null) {\n          _base[ref] = [];\n        }\n        if (__indexOf.call(map.pointers[ref], keypath) < 0) {\n          return map.pointers[ref].push(keypath);\n        }\n      }\n    },\n    unobserveMutations: function(obj, ref, keypath) {\n      var idx, map, pointers;\n      if (Array.isArray(obj) && (obj[this.id] != null)) {\n        if (map = this.weakmap[obj[this.id]]) {\n          if (pointers = map.pointers[ref]) {\n            if ((idx = pointers.indexOf(keypath)) >= 0) {\n              pointers.splice(idx, 1);\n            }\n            if (!pointers.length) {\n              delete map.pointers[ref];\n            }\n            return this.cleanupWeakReference(map, obj[this.id]);\n          }\n        }\n      }\n    },\n    observe: function(obj, keypath, callback) {\n      var callbacks, desc, value;\n      callbacks = this.weakReference(obj).callbacks;\n      if (callbacks[keypath] == null) {\n        callbacks[keypath] = [];\n        desc = Object.getOwnPropertyDescriptor(obj, keypath);\n        if (!((desc != null ? desc.get : void 0) || (desc != null ? desc.set : void 0))) {\n          value = obj[keypath];\n          Object.defineProperty(obj, keypath, {\n            enumerable: true,\n            get: function() {\n              return value;\n            },\n            set: (function(_this) {\n              return function(newValue) {\n                var map, _i, _len, _ref1;\n                if (newValue !== value) {\n                  _this.unobserveMutations(value, obj[_this.id], keypath);\n                  value = newValue;\n                  if (map = _this.weakmap[obj[_this.id]]) {\n                    callbacks = map.callbacks;\n                    if (callbacks[keypath]) {\n                      _ref1 = callbacks[keypath].slice();\n                      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n                        callback = _ref1[_i];\n                        if (__indexOf.call(callbacks[keypath], callback) >= 0) {\n                          callback();\n                        }\n                      }\n                    }\n                    return _this.observeMutations(newValue, obj[_this.id], keypath);\n                  }\n                }\n              };\n            })(this)\n          });\n        }\n      }\n      if (__indexOf.call(callbacks[keypath], callback) < 0) {\n        callbacks[keypath].push(callback);\n      }\n      return this.observeMutations(obj[keypath], obj[this.id], keypath);\n    },\n    unobserve: function(obj, keypath, callback) {\n      var callbacks, idx, map;\n      if (map = this.weakmap[obj[this.id]]) {\n        if (callbacks = map.callbacks[keypath]) {\n          if ((idx = callbacks.indexOf(callback)) >= 0) {\n            callbacks.splice(idx, 1);\n            if (!callbacks.length) {\n              delete map.callbacks[keypath];\n            }\n          }\n          this.unobserveMutations(obj[keypath], obj[this.id], keypath);\n          return this.cleanupWeakReference(map, obj[this.id]);\n        }\n      }\n    },\n    get: function(obj, keypath) {\n      return obj[keypath];\n    },\n    set: function(obj, keypath, value) {\n      return obj[keypath] = value;\n    }\n  };\n\n  Rivets.factory = function(sightglass) {\n    Rivets.sightglass = sightglass;\n    Rivets[\"public\"]._ = Rivets;\n    return Rivets[\"public\"];\n  };\n\n  if (typeof (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) === 'object') {\n    module.exports = Rivets.factory(require('sightglass'));\n  } else if (typeof define === 'function' && define.amd) {\n    define(['sightglass'], function(sightglass) {\n      return this.rivets = Rivets.factory(sightglass);\n    });\n  } else {\n    this.rivets = Rivets.factory(sightglass);\n  }\n\n}).call(this);\n\n},{\"sightglass\":3}],3:[function(require,module,exports){\n(function() {\n  // Public sightglass interface.\n  function sightglass(obj, keypath, callback, options) {\n    return new Observer(obj, keypath, callback, options)\n  }\n\n  // Batteries not included.\n  sightglass.adapters = {}\n\n  // Constructs a new keypath observer and kicks things off.\n  function Observer(obj, keypath, callback, options) {\n    this.options = options || {}\n    this.options.adapters = this.options.adapters || {}\n    this.obj = obj\n    this.keypath = keypath\n    this.callback = callback\n    this.objectPath = []\n    this.update = this.update.bind(this)\n    this.parse()\n\n    if (isObject(this.target = this.realize())) {\n      this.set(true, this.key, this.target, this.callback)\n    }\n  }\n\n  // Tokenizes the provided keypath string into interface + path tokens for the\n  // observer to work with.\n  Observer.tokenize = function(keypath, interfaces, root) {\n    var tokens = []\n    var current = {i: root, path: ''}\n    var index, chr\n\n    for (index = 0; index < keypath.length; index++) {\n      chr = keypath.charAt(index)\n\n      if (!!~interfaces.indexOf(chr)) {\n        tokens.push(current)\n        current = {i: chr, path: ''}\n      } else {\n        current.path += chr\n      }\n    }\n\n    tokens.push(current)\n    return tokens\n  }\n\n  // Parses the keypath using the interfaces defined on the view. Sets variables\n  // for the tokenized keypath as well as the end key.\n  Observer.prototype.parse = function() {\n    var interfaces = this.interfaces()\n    var root, path\n\n    if (!interfaces.length) {\n      error('Must define at least one adapter interface.')\n    }\n\n    if (!!~interfaces.indexOf(this.keypath[0])) {\n      root = this.keypath[0]\n      path = this.keypath.substr(1)\n    } else {\n      if (typeof (root = this.options.root || sightglass.root) === 'undefined') {\n        error('Must define a default root adapter.')\n      }\n\n      path = this.keypath\n    }\n\n    this.tokens = Observer.tokenize(path, interfaces, root)\n    this.key = this.tokens.pop()\n  }\n\n  // Realizes the full keypath, attaching observers for every key and correcting\n  // old observers to any changed objects in the keypath.\n  Observer.prototype.realize = function() {\n    var current = this.obj\n    var unreached = false\n    var prev\n\n    this.tokens.forEach(function(token, index) {\n      if (isObject(current)) {\n        if (typeof this.objectPath[index] !== 'undefined') {\n          if (current !== (prev = this.objectPath[index])) {\n            this.set(false, token, prev, this.update)\n            this.set(true, token, current, this.update)\n            this.objectPath[index] = current\n          }\n        } else {\n          this.set(true, token, current, this.update)\n          this.objectPath[index] = current\n        }\n\n        current = this.get(token, current)\n      } else {\n        if (unreached === false) {\n          unreached = index\n        }\n\n        if (prev = this.objectPath[index]) {\n          this.set(false, token, prev, this.update)\n        }\n      }\n    }, this)\n\n    if (unreached !== false) {\n      this.objectPath.splice(unreached)\n    }\n\n    return current\n  }\n\n  // Updates the keypath. This is called when any intermediary key is changed.\n  Observer.prototype.update = function() {\n    var next, oldValue\n\n    if ((next = this.realize()) !== this.target) {\n      if (isObject(this.target)) {\n        this.set(false, this.key, this.target, this.callback)\n      }\n\n      if (isObject(next)) {\n        this.set(true, this.key, next, this.callback)\n      }\n\n      oldValue = this.value()\n      this.target = next\n\n      if (this.value() !== oldValue) this.callback()\n    }\n  }\n\n  // Reads the current end value of the observed keypath. Returns undefined if\n  // the full keypath is unreachable.\n  Observer.prototype.value = function() {\n    if (isObject(this.target)) {\n      return this.get(this.key, this.target)\n    }\n  }\n\n  // Sets the current end value of the observed keypath. Calling setValue when\n  // the full keypath is unreachable is a no-op.\n  Observer.prototype.setValue = function(value) {\n    if (isObject(this.target)) {\n      this.adapter(this.key).set(this.target, this.key.path, value)\n    }\n  }\n\n  // Gets the provided key on an object.\n  Observer.prototype.get = function(key, obj) {\n    return this.adapter(key).get(obj, key.path)\n  }\n\n  // Observes or unobserves a callback on the object using the provided key.\n  Observer.prototype.set = function(active, key, obj, callback) {\n    var action = active ? 'observe' : 'unobserve'\n    this.adapter(key)[action](obj, key.path, callback)\n  }\n\n  // Returns an array of all unique adapter interfaces available.\n  Observer.prototype.interfaces = function() {\n    var interfaces = Object.keys(this.options.adapters)\n\n    Object.keys(sightglass.adapters).forEach(function(i) {\n      if (!~interfaces.indexOf(i)) {\n        interfaces.push(i)\n      }\n    })\n\n    return interfaces\n  }\n\n  // Convenience function to grab the adapter for a specific key.\n  Observer.prototype.adapter = function(key) {\n    return this.options.adapters[key.i] ||\n      sightglass.adapters[key.i]\n  }\n\n  // Unobserves the entire keypath.\n  Observer.prototype.unobserve = function() {\n    var obj\n\n    this.tokens.forEach(function(token, index) {\n      if (obj = this.objectPath[index]) {\n        this.set(false, token, obj, this.update)\n      }\n    }, this)\n\n    if (isObject(this.target)) {\n      this.set(false, this.key, this.target, this.callback)\n    }\n  }\n\n  // Check if a value is an object than can be observed.\n  function isObject(obj) {\n    return typeof obj === 'object' && obj !== null\n  }\n\n  // Error thrower.\n  function error(message) {\n    throw new Error('[sightglass] ' + message)\n  }\n\n  // Export module for Node and the browser.\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = sightglass\n  } else if (typeof define === 'function' && define.amd) {\n    define([], function() {\n      return this.sightglass = sightglass\n    })\n  } else {\n    this.sightglass = sightglass\n  }\n}).call(this);\n\n},{}]},{},[1])\n\n","// Rivets.js\n// version: 0.8.1\n// author: Michael Richards\n// license: MIT\n(function() {\n  var Rivets, bindMethod, unbindMethod, _ref,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Rivets = {\n    options: ['prefix', 'templateDelimiters', 'rootInterface', 'preloadData', 'handler'],\n    extensions: ['binders', 'formatters', 'components', 'adapters'],\n    \"public\": {\n      binders: {},\n      components: {},\n      formatters: {},\n      adapters: {},\n      prefix: 'rv',\n      templateDelimiters: ['{', '}'],\n      rootInterface: '.',\n      preloadData: true,\n      handler: function(context, ev, binding) {\n        return this.call(context, ev, binding.view.models);\n      },\n      configure: function(options) {\n        var descriptor, key, option, value;\n        if (options == null) {\n          options = {};\n        }\n        for (option in options) {\n          value = options[option];\n          if (option === 'binders' || option === 'components' || option === 'formatters' || option === 'adapters') {\n            for (key in value) {\n              descriptor = value[key];\n              Rivets[option][key] = descriptor;\n            }\n          } else {\n            Rivets[\"public\"][option] = value;\n          }\n        }\n      },\n      bind: function(el, models, options) {\n        var view;\n        if (models == null) {\n          models = {};\n        }\n        if (options == null) {\n          options = {};\n        }\n        view = new Rivets.View(el, models, options);\n        view.bind();\n        return view;\n      },\n      init: function(component, el, data) {\n        var scope, view;\n        if (data == null) {\n          data = {};\n        }\n        if (el == null) {\n          el = document.createElement('div');\n        }\n        component = Rivets[\"public\"].components[component];\n        el.innerHTML = component.template.call(this, el);\n        scope = component.initialize.call(this, el, data);\n        view = new Rivets.View(el, scope);\n        view.bind();\n        return view;\n      }\n    }\n  };\n\n  if (window['jQuery'] || window['$']) {\n    _ref = 'on' in jQuery.prototype ? ['on', 'off'] : ['bind', 'unbind'], bindMethod = _ref[0], unbindMethod = _ref[1];\n    Rivets.Util = {\n      bindEvent: function(el, event, handler) {\n        return jQuery(el)[bindMethod](event, handler);\n      },\n      unbindEvent: function(el, event, handler) {\n        return jQuery(el)[unbindMethod](event, handler);\n      },\n      getInputValue: function(el) {\n        var $el;\n        $el = jQuery(el);\n        if ($el.attr('type') === 'checkbox') {\n          return $el.is(':checked');\n        } else {\n          return $el.val();\n        }\n      }\n    };\n  } else {\n    Rivets.Util = {\n      bindEvent: (function() {\n        if ('addEventListener' in window) {\n          return function(el, event, handler) {\n            return el.addEventListener(event, handler, false);\n          };\n        }\n        return function(el, event, handler) {\n          return el.attachEvent('on' + event, handler);\n        };\n      })(),\n      unbindEvent: (function() {\n        if ('removeEventListener' in window) {\n          return function(el, event, handler) {\n            return el.removeEventListener(event, handler, false);\n          };\n        }\n        return function(el, event, handler) {\n          return el.detachEvent('on' + event, handler);\n        };\n      })(),\n      getInputValue: function(el) {\n        var o, _i, _len, _results;\n        if (el.type === 'checkbox') {\n          return el.checked;\n        } else if (el.type === 'select-multiple') {\n          _results = [];\n          for (_i = 0, _len = el.length; _i < _len; _i++) {\n            o = el[_i];\n            if (o.selected) {\n              _results.push(o.value);\n            }\n          }\n          return _results;\n        } else {\n          return el.value;\n        }\n      }\n    };\n  }\n\n  Rivets.TypeParser = (function() {\n    function TypeParser() {}\n\n    TypeParser.types = {\n      primitive: 0,\n      keypath: 1\n    };\n\n    TypeParser.parse = function(string) {\n      if (/^'.*'$|^\".*\"$/.test(string)) {\n        return {\n          type: this.types.primitive,\n          value: string.slice(1, -1)\n        };\n      } else if (string === 'true') {\n        return {\n          type: this.types.primitive,\n          value: true\n        };\n      } else if (string === 'false') {\n        return {\n          type: this.types.primitive,\n          value: false\n        };\n      } else if (string === 'null') {\n        return {\n          type: this.types.primitive,\n          value: null\n        };\n      } else if (string === 'undefined') {\n        return {\n          type: this.types.primitive,\n          value: void 0\n        };\n      } else if (isNaN(Number(string)) === false) {\n        return {\n          type: this.types.primitive,\n          value: Number(string)\n        };\n      } else {\n        return {\n          type: this.types.keypath,\n          value: string\n        };\n      }\n    };\n\n    return TypeParser;\n\n  })();\n\n  Rivets.TextTemplateParser = (function() {\n    function TextTemplateParser() {}\n\n    TextTemplateParser.types = {\n      text: 0,\n      binding: 1\n    };\n\n    TextTemplateParser.parse = function(template, delimiters) {\n      var index, lastIndex, lastToken, length, substring, tokens, value;\n      tokens = [];\n      length = template.length;\n      index = 0;\n      lastIndex = 0;\n      while (lastIndex < length) {\n        index = template.indexOf(delimiters[0], lastIndex);\n        if (index < 0) {\n          tokens.push({\n            type: this.types.text,\n            value: template.slice(lastIndex)\n          });\n          break;\n        } else {\n          if (index > 0 && lastIndex < index) {\n            tokens.push({\n              type: this.types.text,\n              value: template.slice(lastIndex, index)\n            });\n          }\n          lastIndex = index + delimiters[0].length;\n          index = template.indexOf(delimiters[1], lastIndex);\n          if (index < 0) {\n            substring = template.slice(lastIndex - delimiters[1].length);\n            lastToken = tokens[tokens.length - 1];\n            if ((lastToken != null ? lastToken.type : void 0) === this.types.text) {\n              lastToken.value += substring;\n            } else {\n              tokens.push({\n                type: this.types.text,\n                value: substring\n              });\n            }\n            break;\n          }\n          value = template.slice(lastIndex, index).trim();\n          tokens.push({\n            type: this.types.binding,\n            value: value\n          });\n          lastIndex = index + delimiters[1].length;\n        }\n      }\n      return tokens;\n    };\n\n    return TextTemplateParser;\n\n  })();\n\n  Rivets.View = (function() {\n    function View(els, models, options) {\n      var k, option, v, _base, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5;\n      this.els = els;\n      this.models = models;\n      if (options == null) {\n        options = {};\n      }\n      this.update = __bind(this.update, this);\n      this.publish = __bind(this.publish, this);\n      this.sync = __bind(this.sync, this);\n      this.unbind = __bind(this.unbind, this);\n      this.bind = __bind(this.bind, this);\n      this.select = __bind(this.select, this);\n      this.traverse = __bind(this.traverse, this);\n      this.build = __bind(this.build, this);\n      this.buildBinding = __bind(this.buildBinding, this);\n      this.bindingRegExp = __bind(this.bindingRegExp, this);\n      this.options = __bind(this.options, this);\n      if (!(this.els.jquery || this.els instanceof Array)) {\n        this.els = [this.els];\n      }\n      _ref1 = Rivets.extensions;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        option = _ref1[_i];\n        this[option] = {};\n        if (options[option]) {\n          _ref2 = options[option];\n          for (k in _ref2) {\n            v = _ref2[k];\n            this[option][k] = v;\n          }\n        }\n        _ref3 = Rivets[\"public\"][option];\n        for (k in _ref3) {\n          v = _ref3[k];\n          if ((_base = this[option])[k] == null) {\n            _base[k] = v;\n          }\n        }\n      }\n      _ref4 = Rivets.options;\n      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {\n        option = _ref4[_j];\n        this[option] = (_ref5 = options[option]) != null ? _ref5 : Rivets[\"public\"][option];\n      }\n      this.build();\n    }\n\n    View.prototype.options = function() {\n      var option, options, _i, _len, _ref1;\n      options = {};\n      _ref1 = Rivets.extensions.concat(Rivets.options);\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        option = _ref1[_i];\n        options[option] = this[option];\n      }\n      return options;\n    };\n\n    View.prototype.bindingRegExp = function() {\n      return new RegExp(\"^\" + this.prefix + \"-\");\n    };\n\n    View.prototype.buildBinding = function(binding, node, type, declaration) {\n      var context, ctx, dependencies, keypath, options, pipe, pipes;\n      options = {};\n      pipes = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = declaration.split('|');\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          pipe = _ref1[_i];\n          _results.push(pipe.trim());\n        }\n        return _results;\n      })();\n      context = (function() {\n        var _i, _len, _ref1, _results;\n        _ref1 = pipes.shift().split('<');\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          ctx = _ref1[_i];\n          _results.push(ctx.trim());\n        }\n        return _results;\n      })();\n      keypath = context.shift();\n      options.formatters = pipes;\n      if (dependencies = context.shift()) {\n        options.dependencies = dependencies.split(/\\s+/);\n      }\n      return this.bindings.push(new Rivets[binding](this, node, type, keypath, options));\n    };\n\n    View.prototype.build = function() {\n      var el, parse, _i, _len, _ref1;\n      this.bindings = [];\n      parse = (function(_this) {\n        return function(node) {\n          var block, childNode, delimiters, n, parser, text, token, tokens, _i, _j, _len, _len1, _ref1, _results;\n          if (node.nodeType === 3) {\n            parser = Rivets.TextTemplateParser;\n            if (delimiters = _this.templateDelimiters) {\n              if ((tokens = parser.parse(node.data, delimiters)).length) {\n                if (!(tokens.length === 1 && tokens[0].type === parser.types.text)) {\n                  for (_i = 0, _len = tokens.length; _i < _len; _i++) {\n                    token = tokens[_i];\n                    text = document.createTextNode(token.value);\n                    node.parentNode.insertBefore(text, node);\n                    if (token.type === 1) {\n                      _this.buildBinding('TextBinding', text, null, token.value);\n                    }\n                  }\n                  node.parentNode.removeChild(node);\n                }\n              }\n            }\n          } else if (node.nodeType === 1) {\n            block = _this.traverse(node);\n          }\n          if (!block) {\n            _ref1 = (function() {\n              var _k, _len1, _ref1, _results1;\n              _ref1 = node.childNodes;\n              _results1 = [];\n              for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {\n                n = _ref1[_k];\n                _results1.push(n);\n              }\n              return _results1;\n            })();\n            _results = [];\n            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n              childNode = _ref1[_j];\n              _results.push(parse(childNode));\n            }\n            return _results;\n          }\n        };\n      })(this);\n      _ref1 = this.els;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        el = _ref1[_i];\n        parse(el);\n      }\n      this.bindings.sort(function(a, b) {\n        var _ref2, _ref3;\n        return (((_ref2 = b.binder) != null ? _ref2.priority : void 0) || 0) - (((_ref3 = a.binder) != null ? _ref3.priority : void 0) || 0);\n      });\n    };\n\n    View.prototype.traverse = function(node) {\n      var attribute, attributes, binder, bindingRegExp, block, identifier, regexp, type, value, _i, _j, _len, _len1, _ref1, _ref2, _ref3;\n      bindingRegExp = this.bindingRegExp();\n      block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE';\n      _ref1 = node.attributes;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        attribute = _ref1[_i];\n        if (bindingRegExp.test(attribute.name)) {\n          type = attribute.name.replace(bindingRegExp, '');\n          if (!(binder = this.binders[type])) {\n            _ref2 = this.binders;\n            for (identifier in _ref2) {\n              value = _ref2[identifier];\n              if (identifier !== '*' && identifier.indexOf('*') !== -1) {\n                regexp = new RegExp(\"^\" + (identifier.replace(/\\*/g, '.+')) + \"$\");\n                if (regexp.test(type)) {\n                  binder = value;\n                }\n              }\n            }\n          }\n          binder || (binder = this.binders['*']);\n          if (binder.block) {\n            block = true;\n            attributes = [attribute];\n          }\n        }\n      }\n      _ref3 = attributes || node.attributes;\n      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {\n        attribute = _ref3[_j];\n        if (bindingRegExp.test(attribute.name)) {\n          type = attribute.name.replace(bindingRegExp, '');\n          this.buildBinding('Binding', node, type, attribute.value);\n        }\n      }\n      if (!block) {\n        type = node.nodeName.toLowerCase();\n        if (this.components[type] && !node._bound) {\n          this.bindings.push(new Rivets.ComponentBinding(this, node, type));\n          block = true;\n        }\n      }\n      return block;\n    };\n\n    View.prototype.select = function(fn) {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        if (fn(binding)) {\n          _results.push(binding);\n        }\n      }\n      return _results;\n    };\n\n    View.prototype.bind = function() {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(binding.bind());\n      }\n      return _results;\n    };\n\n    View.prototype.unbind = function() {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(binding.unbind());\n      }\n      return _results;\n    };\n\n    View.prototype.sync = function() {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(typeof binding.sync === \"function\" ? binding.sync() : void 0);\n      }\n      return _results;\n    };\n\n    View.prototype.publish = function() {\n      var binding, _i, _len, _ref1, _results;\n      _ref1 = this.select(function(b) {\n        var _ref1;\n        return (_ref1 = b.binder) != null ? _ref1.publishes : void 0;\n      });\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(binding.publish());\n      }\n      return _results;\n    };\n\n    View.prototype.update = function(models) {\n      var binding, key, model, _i, _len, _ref1, _results;\n      if (models == null) {\n        models = {};\n      }\n      for (key in models) {\n        model = models[key];\n        this.models[key] = model;\n      }\n      _ref1 = this.bindings;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        binding = _ref1[_i];\n        _results.push(typeof binding.update === \"function\" ? binding.update(models) : void 0);\n      }\n      return _results;\n    };\n\n    return View;\n\n  })();\n\n  Rivets.Binding = (function() {\n    function Binding(view, el, type, keypath, options) {\n      this.view = view;\n      this.el = el;\n      this.type = type;\n      this.keypath = keypath;\n      this.options = options != null ? options : {};\n      this.getValue = __bind(this.getValue, this);\n      this.update = __bind(this.update, this);\n      this.unbind = __bind(this.unbind, this);\n      this.bind = __bind(this.bind, this);\n      this.publish = __bind(this.publish, this);\n      this.sync = __bind(this.sync, this);\n      this.set = __bind(this.set, this);\n      this.eventHandler = __bind(this.eventHandler, this);\n      this.formattedValue = __bind(this.formattedValue, this);\n      this.parseTarget = __bind(this.parseTarget, this);\n      this.observe = __bind(this.observe, this);\n      this.setBinder = __bind(this.setBinder, this);\n      this.formatters = this.options.formatters || [];\n      this.dependencies = [];\n      this.formatterObservers = {};\n      this.model = void 0;\n      this.setBinder();\n    }\n\n    Binding.prototype.setBinder = function() {\n      var identifier, regexp, value, _ref1;\n      if (!(this.binder = this.view.binders[this.type])) {\n        _ref1 = this.view.binders;\n        for (identifier in _ref1) {\n          value = _ref1[identifier];\n          if (identifier !== '*' && identifier.indexOf('*') !== -1) {\n            regexp = new RegExp(\"^\" + (identifier.replace(/\\*/g, '.+')) + \"$\");\n            if (regexp.test(this.type)) {\n              this.binder = value;\n              this.args = new RegExp(\"^\" + (identifier.replace(/\\*/g, '(.+)')) + \"$\").exec(this.type);\n              this.args.shift();\n            }\n          }\n        }\n      }\n      this.binder || (this.binder = this.view.binders['*']);\n      if (this.binder instanceof Function) {\n        return this.binder = {\n          routine: this.binder\n        };\n      }\n    };\n\n    Binding.prototype.observe = function(obj, keypath, callback) {\n      return Rivets.sightglass(obj, keypath, callback, {\n        root: this.view.rootInterface,\n        adapters: this.view.adapters\n      });\n    };\n\n    Binding.prototype.parseTarget = function() {\n      var token;\n      token = Rivets.TypeParser.parse(this.keypath);\n      if (token.type === 0) {\n        return this.value = token.value;\n      } else {\n        this.observer = this.observe(this.view.models, this.keypath, this.sync);\n        return this.model = this.observer.target;\n      }\n    };\n\n    Binding.prototype.formattedValue = function(value) {\n      var ai, arg, args, fi, formatter, id, observer, processedArgs, _base, _i, _j, _len, _len1, _ref1;\n      _ref1 = this.formatters;\n      for (fi = _i = 0, _len = _ref1.length; _i < _len; fi = ++_i) {\n        formatter = _ref1[fi];\n        args = formatter.match(/[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g);\n        id = args.shift();\n        formatter = this.view.formatters[id];\n        args = (function() {\n          var _j, _len1, _results;\n          _results = [];\n          for (_j = 0, _len1 = args.length; _j < _len1; _j++) {\n            arg = args[_j];\n            _results.push(Rivets.TypeParser.parse(arg));\n          }\n          return _results;\n        })();\n        processedArgs = [];\n        for (ai = _j = 0, _len1 = args.length; _j < _len1; ai = ++_j) {\n          arg = args[ai];\n          processedArgs.push(arg.type === 0 ? arg.value : ((_base = this.formatterObservers)[fi] || (_base[fi] = {}), !(observer = this.formatterObservers[fi][ai]) ? (observer = this.observe(this.view.models, arg.value, this.sync), this.formatterObservers[fi][ai] = observer) : void 0, observer.value()));\n        }\n        if ((formatter != null ? formatter.read : void 0) instanceof Function) {\n          value = formatter.read.apply(formatter, [value].concat(__slice.call(processedArgs)));\n        } else if (formatter instanceof Function) {\n          value = formatter.apply(null, [value].concat(__slice.call(processedArgs)));\n        }\n      }\n      return value;\n    };\n\n    Binding.prototype.eventHandler = function(fn) {\n      var binding, handler;\n      handler = (binding = this).view.handler;\n      return function(ev) {\n        return handler.call(fn, this, ev, binding);\n      };\n    };\n\n    Binding.prototype.set = function(value) {\n      var _ref1;\n      value = value instanceof Function && !this.binder[\"function\"] ? this.formattedValue(value.call(this.model)) : this.formattedValue(value);\n      return (_ref1 = this.binder.routine) != null ? _ref1.call(this, this.el, value) : void 0;\n    };\n\n    Binding.prototype.sync = function() {\n      var dependency, observer;\n      return this.set((function() {\n        var _i, _j, _len, _len1, _ref1, _ref2, _ref3;\n        if (this.observer) {\n          if (this.model !== this.observer.target) {\n            _ref1 = this.dependencies;\n            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n              observer = _ref1[_i];\n              observer.unobserve();\n            }\n            this.dependencies = [];\n            if (((this.model = this.observer.target) != null) && ((_ref2 = this.options.dependencies) != null ? _ref2.length : void 0)) {\n              _ref3 = this.options.dependencies;\n              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {\n                dependency = _ref3[_j];\n                observer = this.observe(this.model, dependency, this.sync);\n                this.dependencies.push(observer);\n              }\n            }\n          }\n          return this.observer.value();\n        } else {\n          return this.value;\n        }\n      }).call(this));\n    };\n\n    Binding.prototype.publish = function() {\n      var args, formatter, id, value, _i, _len, _ref1, _ref2, _ref3;\n      if (this.observer) {\n        value = this.getValue(this.el);\n        _ref1 = this.formatters.slice(0).reverse();\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          formatter = _ref1[_i];\n          args = formatter.split(/\\s+/);\n          id = args.shift();\n          if ((_ref2 = this.view.formatters[id]) != null ? _ref2.publish : void 0) {\n            value = (_ref3 = this.view.formatters[id]).publish.apply(_ref3, [value].concat(__slice.call(args)));\n          }\n        }\n        return this.observer.setValue(value);\n      }\n    };\n\n    Binding.prototype.bind = function() {\n      var dependency, observer, _i, _len, _ref1, _ref2, _ref3;\n      this.parseTarget();\n      if ((_ref1 = this.binder.bind) != null) {\n        _ref1.call(this, this.el);\n      }\n      if ((this.model != null) && ((_ref2 = this.options.dependencies) != null ? _ref2.length : void 0)) {\n        _ref3 = this.options.dependencies;\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          dependency = _ref3[_i];\n          observer = this.observe(this.model, dependency, this.sync);\n          this.dependencies.push(observer);\n        }\n      }\n      if (this.view.preloadData) {\n        return this.sync();\n      }\n    };\n\n    Binding.prototype.unbind = function() {\n      var ai, args, fi, observer, _i, _len, _ref1, _ref2, _ref3, _ref4;\n      if ((_ref1 = this.binder.unbind) != null) {\n        _ref1.call(this, this.el);\n      }\n      if ((_ref2 = this.observer) != null) {\n        _ref2.unobserve();\n      }\n      _ref3 = this.dependencies;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        observer = _ref3[_i];\n        observer.unobserve();\n      }\n      this.dependencies = [];\n      _ref4 = this.formatterObservers;\n      for (fi in _ref4) {\n        args = _ref4[fi];\n        for (ai in args) {\n          observer = args[ai];\n          observer.unobserve();\n        }\n      }\n      return this.formatterObservers = {};\n    };\n\n    Binding.prototype.update = function(models) {\n      var _ref1, _ref2;\n      if (models == null) {\n        models = {};\n      }\n      this.model = (_ref1 = this.observer) != null ? _ref1.target : void 0;\n      return (_ref2 = this.binder.update) != null ? _ref2.call(this, models) : void 0;\n    };\n\n    Binding.prototype.getValue = function(el) {\n      if (this.binder && (this.binder.getValue != null)) {\n        return this.binder.getValue.call(this, el);\n      } else {\n        return Rivets.Util.getInputValue(el);\n      }\n    };\n\n    return Binding;\n\n  })();\n\n  Rivets.ComponentBinding = (function(_super) {\n    __extends(ComponentBinding, _super);\n\n    function ComponentBinding(view, el, type) {\n      var attribute, bindingRegExp, propertyName, _i, _len, _ref1, _ref2;\n      this.view = view;\n      this.el = el;\n      this.type = type;\n      this.unbind = __bind(this.unbind, this);\n      this.bind = __bind(this.bind, this);\n      this.locals = __bind(this.locals, this);\n      this.component = this.view.components[this.type];\n      this[\"static\"] = {};\n      this.observers = {};\n      this.upstreamObservers = {};\n      bindingRegExp = view.bindingRegExp();\n      _ref1 = this.el.attributes || [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        attribute = _ref1[_i];\n        if (!bindingRegExp.test(attribute.name)) {\n          propertyName = this.camelCase(attribute.name);\n          if (__indexOf.call((_ref2 = this.component[\"static\"]) != null ? _ref2 : [], propertyName) >= 0) {\n            this[\"static\"][propertyName] = attribute.value;\n          } else {\n            this.observers[propertyName] = attribute.value;\n          }\n        }\n      }\n    }\n\n    ComponentBinding.prototype.sync = function() {};\n\n    ComponentBinding.prototype.update = function() {};\n\n    ComponentBinding.prototype.publish = function() {};\n\n    ComponentBinding.prototype.locals = function() {\n      var key, observer, result, value, _ref1, _ref2;\n      result = {};\n      _ref1 = this[\"static\"];\n      for (key in _ref1) {\n        value = _ref1[key];\n        result[key] = value;\n      }\n      _ref2 = this.observers;\n      for (key in _ref2) {\n        observer = _ref2[key];\n        result[key] = observer.value();\n      }\n      return result;\n    };\n\n    ComponentBinding.prototype.camelCase = function(string) {\n      return string.replace(/-([a-z])/g, function(grouped) {\n        return grouped[1].toUpperCase();\n      });\n    };\n\n    ComponentBinding.prototype.bind = function() {\n      var k, key, keypath, observer, option, options, scope, v, _base, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _results;\n      if (!this.bound) {\n        _ref1 = this.observers;\n        for (key in _ref1) {\n          keypath = _ref1[key];\n          this.observers[key] = this.observe(this.view.models, keypath, ((function(_this) {\n            return function(key) {\n              return function() {\n                return _this.componentView.models[key] = _this.observers[key].value();\n              };\n            };\n          })(this)).call(this, key));\n        }\n        this.bound = true;\n      }\n      if (this.componentView != null) {\n        return this.componentView.bind();\n      } else {\n        this.el.innerHTML = this.component.template.call(this);\n        scope = this.component.initialize.call(this, this.el, this.locals());\n        this.el._bound = true;\n        options = {};\n        _ref2 = Rivets.extensions;\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          option = _ref2[_i];\n          options[option] = {};\n          if (this.component[option]) {\n            _ref3 = this.component[option];\n            for (k in _ref3) {\n              v = _ref3[k];\n              options[option][k] = v;\n            }\n          }\n          _ref4 = this.view[option];\n          for (k in _ref4) {\n            v = _ref4[k];\n            if ((_base = options[option])[k] == null) {\n              _base[k] = v;\n            }\n          }\n        }\n        _ref5 = Rivets.options;\n        for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {\n          option = _ref5[_j];\n          options[option] = (_ref6 = this.component[option]) != null ? _ref6 : this.view[option];\n        }\n        this.componentView = new Rivets.View(this.el, scope, options);\n        this.componentView.bind();\n        _ref7 = this.observers;\n        _results = [];\n        for (key in _ref7) {\n          observer = _ref7[key];\n          _results.push(this.upstreamObservers[key] = this.observe(this.componentView.models, key, ((function(_this) {\n            return function(key, observer) {\n              return function() {\n                return observer.setValue(_this.componentView.models[key]);\n              };\n            };\n          })(this)).call(this, key, observer)));\n        }\n        return _results;\n      }\n    };\n\n    ComponentBinding.prototype.unbind = function() {\n      var key, observer, _ref1, _ref2, _ref3;\n      _ref1 = this.upstreamObservers;\n      for (key in _ref1) {\n        observer = _ref1[key];\n        observer.unobserve();\n      }\n      _ref2 = this.observers;\n      for (key in _ref2) {\n        observer = _ref2[key];\n        observer.unobserve();\n      }\n      return (_ref3 = this.componentView) != null ? _ref3.unbind.call(this) : void 0;\n    };\n\n    return ComponentBinding;\n\n  })(Rivets.Binding);\n\n  Rivets.TextBinding = (function(_super) {\n    __extends(TextBinding, _super);\n\n    function TextBinding(view, el, type, keypath, options) {\n      this.view = view;\n      this.el = el;\n      this.type = type;\n      this.keypath = keypath;\n      this.options = options != null ? options : {};\n      this.sync = __bind(this.sync, this);\n      this.formatters = this.options.formatters || [];\n      this.dependencies = [];\n      this.formatterObservers = {};\n    }\n\n    TextBinding.prototype.binder = {\n      routine: function(node, value) {\n        return node.data = value != null ? value : '';\n      }\n    };\n\n    TextBinding.prototype.sync = function() {\n      return TextBinding.__super__.sync.apply(this, arguments);\n    };\n\n    return TextBinding;\n\n  })(Rivets.Binding);\n\n  Rivets[\"public\"].binders.text = function(el, value) {\n    if (el.textContent != null) {\n      return el.textContent = value != null ? value : '';\n    } else {\n      return el.innerText = value != null ? value : '';\n    }\n  };\n\n  Rivets[\"public\"].binders.html = function(el, value) {\n    return el.innerHTML = value != null ? value : '';\n  };\n\n  Rivets[\"public\"].binders.show = function(el, value) {\n    return el.style.display = value ? '' : 'none';\n  };\n\n  Rivets[\"public\"].binders.hide = function(el, value) {\n    return el.style.display = value ? 'none' : '';\n  };\n\n  Rivets[\"public\"].binders.enabled = function(el, value) {\n    return el.disabled = !value;\n  };\n\n  Rivets[\"public\"].binders.disabled = function(el, value) {\n    return el.disabled = !!value;\n  };\n\n  Rivets[\"public\"].binders.checked = {\n    publishes: true,\n    priority: 2000,\n    bind: function(el) {\n      return Rivets.Util.bindEvent(el, 'change', this.publish);\n    },\n    unbind: function(el) {\n      return Rivets.Util.unbindEvent(el, 'change', this.publish);\n    },\n    routine: function(el, value) {\n      var _ref1;\n      if (el.type === 'radio') {\n        return el.checked = ((_ref1 = el.value) != null ? _ref1.toString() : void 0) === (value != null ? value.toString() : void 0);\n      } else {\n        return el.checked = !!value;\n      }\n    }\n  };\n\n  Rivets[\"public\"].binders.unchecked = {\n    publishes: true,\n    priority: 2000,\n    bind: function(el) {\n      return Rivets.Util.bindEvent(el, 'change', this.publish);\n    },\n    unbind: function(el) {\n      return Rivets.Util.unbindEvent(el, 'change', this.publish);\n    },\n    routine: function(el, value) {\n      var _ref1;\n      if (el.type === 'radio') {\n        return el.checked = ((_ref1 = el.value) != null ? _ref1.toString() : void 0) !== (value != null ? value.toString() : void 0);\n      } else {\n        return el.checked = !value;\n      }\n    }\n  };\n\n  Rivets[\"public\"].binders.value = {\n    publishes: true,\n    priority: 3000,\n    bind: function(el) {\n      if (!(el.tagName === 'INPUT' && el.type === 'radio')) {\n        this.event = el.tagName === 'SELECT' ? 'change' : 'input';\n        return Rivets.Util.bindEvent(el, this.event, this.publish);\n      }\n    },\n    unbind: function(el) {\n      if (!(el.tagName === 'INPUT' && el.type === 'radio')) {\n        return Rivets.Util.unbindEvent(el, this.event, this.publish);\n      }\n    },\n    routine: function(el, value) {\n      var o, _i, _len, _ref1, _ref2, _ref3, _results;\n      if (el.tagName === 'INPUT' && el.type === 'radio') {\n        return el.setAttribute('value', value);\n      } else if (window.jQuery != null) {\n        el = jQuery(el);\n        if ((value != null ? value.toString() : void 0) !== ((_ref1 = el.val()) != null ? _ref1.toString() : void 0)) {\n          return el.val(value != null ? value : '');\n        }\n      } else {\n        if (el.type === 'select-multiple') {\n          if (value != null) {\n            _results = [];\n            for (_i = 0, _len = el.length; _i < _len; _i++) {\n              o = el[_i];\n              _results.push(o.selected = (_ref2 = o.value, __indexOf.call(value, _ref2) >= 0));\n            }\n            return _results;\n          }\n        } else if ((value != null ? value.toString() : void 0) !== ((_ref3 = el.value) != null ? _ref3.toString() : void 0)) {\n          return el.value = value != null ? value : '';\n        }\n      }\n    }\n  };\n\n  Rivets[\"public\"].binders[\"if\"] = {\n    block: true,\n    priority: 4000,\n    bind: function(el) {\n      var attr, declaration;\n      if (this.marker == null) {\n        attr = [this.view.prefix, this.type].join('-').replace('--', '-');\n        declaration = el.getAttribute(attr);\n        this.marker = document.createComment(\" rivets: \" + this.type + \" \" + declaration + \" \");\n        this.bound = false;\n        el.removeAttribute(attr);\n        el.parentNode.insertBefore(this.marker, el);\n        return el.parentNode.removeChild(el);\n      }\n    },\n    unbind: function() {\n      var _ref1;\n      return (_ref1 = this.nested) != null ? _ref1.unbind() : void 0;\n    },\n    routine: function(el, value) {\n      var key, model, models, _ref1;\n      if (!!value === !this.bound) {\n        if (value) {\n          models = {};\n          _ref1 = this.view.models;\n          for (key in _ref1) {\n            model = _ref1[key];\n            models[key] = model;\n          }\n          (this.nested || (this.nested = new Rivets.View(el, models, this.view.options()))).bind();\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling);\n          return this.bound = true;\n        } else {\n          el.parentNode.removeChild(el);\n          this.nested.unbind();\n          return this.bound = false;\n        }\n      }\n    },\n    update: function(models) {\n      var _ref1;\n      return (_ref1 = this.nested) != null ? _ref1.update(models) : void 0;\n    }\n  };\n\n  Rivets[\"public\"].binders.unless = {\n    block: true,\n    priority: 4000,\n    bind: function(el) {\n      return Rivets[\"public\"].binders[\"if\"].bind.call(this, el);\n    },\n    unbind: function() {\n      return Rivets[\"public\"].binders[\"if\"].unbind.call(this);\n    },\n    routine: function(el, value) {\n      return Rivets[\"public\"].binders[\"if\"].routine.call(this, el, !value);\n    },\n    update: function(models) {\n      return Rivets[\"public\"].binders[\"if\"].update.call(this, models);\n    }\n  };\n\n  Rivets[\"public\"].binders['on-*'] = {\n    \"function\": true,\n    priority: 1000,\n    unbind: function(el) {\n      if (this.handler) {\n        return Rivets.Util.unbindEvent(el, this.args[0], this.handler);\n      }\n    },\n    routine: function(el, value) {\n      if (this.handler) {\n        Rivets.Util.unbindEvent(el, this.args[0], this.handler);\n      }\n      return Rivets.Util.bindEvent(el, this.args[0], this.handler = this.eventHandler(value));\n    }\n  };\n\n  Rivets[\"public\"].binders['each-*'] = {\n    block: true,\n    priority: 4000,\n    bind: function(el) {\n      var attr, view, _i, _len, _ref1;\n      if (this.marker == null) {\n        attr = [this.view.prefix, this.type].join('-').replace('--', '-');\n        this.marker = document.createComment(\" rivets: \" + this.type + \" \");\n        this.iterated = [];\n        el.removeAttribute(attr);\n        el.parentNode.insertBefore(this.marker, el);\n        el.parentNode.removeChild(el);\n      } else {\n        _ref1 = this.iterated;\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          view = _ref1[_i];\n          view.bind();\n        }\n      }\n    },\n    unbind: function(el) {\n      var view, _i, _len, _ref1, _results;\n      if (this.iterated != null) {\n        _ref1 = this.iterated;\n        _results = [];\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          view = _ref1[_i];\n          _results.push(view.unbind());\n        }\n        return _results;\n      }\n    },\n    routine: function(el, collection) {\n      var binding, data, i, index, key, model, modelName, options, previous, template, view, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;\n      modelName = this.args[0];\n      collection = collection || [];\n      if (this.iterated.length > collection.length) {\n        _ref1 = Array(this.iterated.length - collection.length);\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          i = _ref1[_i];\n          view = this.iterated.pop();\n          view.unbind();\n          this.marker.parentNode.removeChild(view.els[0]);\n        }\n      }\n      for (index = _j = 0, _len1 = collection.length; _j < _len1; index = ++_j) {\n        model = collection[index];\n        data = {\n          index: index\n        };\n        data[modelName] = model;\n        if (this.iterated[index] == null) {\n          _ref2 = this.view.models;\n          for (key in _ref2) {\n            model = _ref2[key];\n            if (data[key] == null) {\n              data[key] = model;\n            }\n          }\n          previous = this.iterated.length ? this.iterated[this.iterated.length - 1].els[0] : this.marker;\n          options = this.view.options();\n          options.preloadData = true;\n          template = el.cloneNode(true);\n          view = new Rivets.View(template, data, options);\n          view.bind();\n          this.iterated.push(view);\n          this.marker.parentNode.insertBefore(template, previous.nextSibling);\n        } else if (this.iterated[index].models[modelName] !== model) {\n          this.iterated[index].update(data);\n        }\n      }\n      if (el.nodeName === 'OPTION') {\n        _ref3 = this.view.bindings;\n        _results = [];\n        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n          binding = _ref3[_k];\n          if (binding.el === this.marker.parentNode && binding.type === 'value') {\n            _results.push(binding.sync());\n          } else {\n            _results.push(void 0);\n          }\n        }\n        return _results;\n      }\n    },\n    update: function(models) {\n      var data, key, model, view, _i, _len, _ref1, _results;\n      data = {};\n      for (key in models) {\n        model = models[key];\n        if (key !== this.args[0]) {\n          data[key] = model;\n        }\n      }\n      _ref1 = this.iterated;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        view = _ref1[_i];\n        _results.push(view.update(data));\n      }\n      return _results;\n    }\n  };\n\n  Rivets[\"public\"].binders['class-*'] = function(el, value) {\n    var elClass;\n    elClass = \" \" + el.className + \" \";\n    if (!value === (elClass.indexOf(\" \" + this.args[0] + \" \") !== -1)) {\n      return el.className = value ? \"\" + el.className + \" \" + this.args[0] : elClass.replace(\" \" + this.args[0] + \" \", ' ').trim();\n    }\n  };\n\n  Rivets[\"public\"].binders['*'] = function(el, value) {\n    if (value != null) {\n      return el.setAttribute(this.type, value);\n    } else {\n      return el.removeAttribute(this.type);\n    }\n  };\n\n  Rivets[\"public\"].adapters['.'] = {\n    id: '_rv',\n    counter: 0,\n    weakmap: {},\n    weakReference: function(obj) {\n      var id, _base, _name;\n      if (!obj.hasOwnProperty(this.id)) {\n        id = this.counter++;\n        Object.defineProperty(obj, this.id, {\n          value: id\n        });\n      }\n      return (_base = this.weakmap)[_name = obj[this.id]] || (_base[_name] = {\n        callbacks: {}\n      });\n    },\n    cleanupWeakReference: function(ref, id) {\n      if (!Object.keys(ref.callbacks).length) {\n        if (!(ref.pointers && Object.keys(ref.pointers).length)) {\n          return delete this.weakmap[id];\n        }\n      }\n    },\n    stubFunction: function(obj, fn) {\n      var map, original, weakmap;\n      original = obj[fn];\n      map = this.weakReference(obj);\n      weakmap = this.weakmap;\n      return obj[fn] = function() {\n        var callback, k, r, response, _i, _len, _ref1, _ref2, _ref3, _ref4;\n        response = original.apply(obj, arguments);\n        _ref1 = map.pointers;\n        for (r in _ref1) {\n          k = _ref1[r];\n          _ref4 = (_ref2 = (_ref3 = weakmap[r]) != null ? _ref3.callbacks[k] : void 0) != null ? _ref2 : [];\n          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {\n            callback = _ref4[_i];\n            callback();\n          }\n        }\n        return response;\n      };\n    },\n    observeMutations: function(obj, ref, keypath) {\n      var fn, functions, map, _base, _i, _len;\n      if (Array.isArray(obj)) {\n        map = this.weakReference(obj);\n        if (map.pointers == null) {\n          map.pointers = {};\n          functions = ['push', 'pop', 'shift', 'unshift', 'sort', 'reverse', 'splice'];\n          for (_i = 0, _len = functions.length; _i < _len; _i++) {\n            fn = functions[_i];\n            this.stubFunction(obj, fn);\n          }\n        }\n        if ((_base = map.pointers)[ref] == null) {\n          _base[ref] = [];\n        }\n        if (__indexOf.call(map.pointers[ref], keypath) < 0) {\n          return map.pointers[ref].push(keypath);\n        }\n      }\n    },\n    unobserveMutations: function(obj, ref, keypath) {\n      var idx, map, pointers;\n      if (Array.isArray(obj) && (obj[this.id] != null)) {\n        if (map = this.weakmap[obj[this.id]]) {\n          if (pointers = map.pointers[ref]) {\n            if ((idx = pointers.indexOf(keypath)) >= 0) {\n              pointers.splice(idx, 1);\n            }\n            if (!pointers.length) {\n              delete map.pointers[ref];\n            }\n            return this.cleanupWeakReference(map, obj[this.id]);\n          }\n        }\n      }\n    },\n    observe: function(obj, keypath, callback) {\n      var callbacks, desc, value;\n      callbacks = this.weakReference(obj).callbacks;\n      if (callbacks[keypath] == null) {\n        callbacks[keypath] = [];\n        desc = Object.getOwnPropertyDescriptor(obj, keypath);\n        if (!((desc != null ? desc.get : void 0) || (desc != null ? desc.set : void 0))) {\n          value = obj[keypath];\n          Object.defineProperty(obj, keypath, {\n            enumerable: true,\n            get: function() {\n              return value;\n            },\n            set: (function(_this) {\n              return function(newValue) {\n                var map, _i, _len, _ref1;\n                if (newValue !== value) {\n                  _this.unobserveMutations(value, obj[_this.id], keypath);\n                  value = newValue;\n                  if (map = _this.weakmap[obj[_this.id]]) {\n                    callbacks = map.callbacks;\n                    if (callbacks[keypath]) {\n                      _ref1 = callbacks[keypath].slice();\n                      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n                        callback = _ref1[_i];\n                        if (__indexOf.call(callbacks[keypath], callback) >= 0) {\n                          callback();\n                        }\n                      }\n                    }\n                    return _this.observeMutations(newValue, obj[_this.id], keypath);\n                  }\n                }\n              };\n            })(this)\n          });\n        }\n      }\n      if (__indexOf.call(callbacks[keypath], callback) < 0) {\n        callbacks[keypath].push(callback);\n      }\n      return this.observeMutations(obj[keypath], obj[this.id], keypath);\n    },\n    unobserve: function(obj, keypath, callback) {\n      var callbacks, idx, map;\n      if (map = this.weakmap[obj[this.id]]) {\n        if (callbacks = map.callbacks[keypath]) {\n          if ((idx = callbacks.indexOf(callback)) >= 0) {\n            callbacks.splice(idx, 1);\n            if (!callbacks.length) {\n              delete map.callbacks[keypath];\n            }\n          }\n          this.unobserveMutations(obj[keypath], obj[this.id], keypath);\n          return this.cleanupWeakReference(map, obj[this.id]);\n        }\n      }\n    },\n    get: function(obj, keypath) {\n      return obj[keypath];\n    },\n    set: function(obj, keypath, value) {\n      return obj[keypath] = value;\n    }\n  };\n\n  Rivets.factory = function(sightglass) {\n    Rivets.sightglass = sightglass;\n    Rivets[\"public\"]._ = Rivets;\n    return Rivets[\"public\"];\n  };\n\n  if (typeof (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) === 'object') {\n    module.exports = Rivets.factory(require('sightglass'));\n  } else if (typeof define === 'function' && define.amd) {\n    define(['sightglass'], function(sightglass) {\n      return this.rivets = Rivets.factory(sightglass);\n    });\n  } else {\n    this.rivets = Rivets.factory(sightglass);\n  }\n\n}).call(this);\n","(function() {\n  // Public sightglass interface.\n  function sightglass(obj, keypath, callback, options) {\n    return new Observer(obj, keypath, callback, options)\n  }\n\n  // Batteries not included.\n  sightglass.adapters = {}\n\n  // Constructs a new keypath observer and kicks things off.\n  function Observer(obj, keypath, callback, options) {\n    this.options = options || {}\n    this.options.adapters = this.options.adapters || {}\n    this.obj = obj\n    this.keypath = keypath\n    this.callback = callback\n    this.objectPath = []\n    this.update = this.update.bind(this)\n    this.parse()\n\n    if (isObject(this.target = this.realize())) {\n      this.set(true, this.key, this.target, this.callback)\n    }\n  }\n\n  // Tokenizes the provided keypath string into interface + path tokens for the\n  // observer to work with.\n  Observer.tokenize = function(keypath, interfaces, root) {\n    var tokens = []\n    var current = {i: root, path: ''}\n    var index, chr\n\n    for (index = 0; index < keypath.length; index++) {\n      chr = keypath.charAt(index)\n\n      if (!!~interfaces.indexOf(chr)) {\n        tokens.push(current)\n        current = {i: chr, path: ''}\n      } else {\n        current.path += chr\n      }\n    }\n\n    tokens.push(current)\n    return tokens\n  }\n\n  // Parses the keypath using the interfaces defined on the view. Sets variables\n  // for the tokenized keypath as well as the end key.\n  Observer.prototype.parse = function() {\n    var interfaces = this.interfaces()\n    var root, path\n\n    if (!interfaces.length) {\n      error('Must define at least one adapter interface.')\n    }\n\n    if (!!~interfaces.indexOf(this.keypath[0])) {\n      root = this.keypath[0]\n      path = this.keypath.substr(1)\n    } else {\n      if (typeof (root = this.options.root || sightglass.root) === 'undefined') {\n        error('Must define a default root adapter.')\n      }\n\n      path = this.keypath\n    }\n\n    this.tokens = Observer.tokenize(path, interfaces, root)\n    this.key = this.tokens.pop()\n  }\n\n  // Realizes the full keypath, attaching observers for every key and correcting\n  // old observers to any changed objects in the keypath.\n  Observer.prototype.realize = function() {\n    var current = this.obj\n    var unreached = false\n    var prev\n\n    this.tokens.forEach(function(token, index) {\n      if (isObject(current)) {\n        if (typeof this.objectPath[index] !== 'undefined') {\n          if (current !== (prev = this.objectPath[index])) {\n            this.set(false, token, prev, this.update)\n            this.set(true, token, current, this.update)\n            this.objectPath[index] = current\n          }\n        } else {\n          this.set(true, token, current, this.update)\n          this.objectPath[index] = current\n        }\n\n        current = this.get(token, current)\n      } else {\n        if (unreached === false) {\n          unreached = index\n        }\n\n        if (prev = this.objectPath[index]) {\n          this.set(false, token, prev, this.update)\n        }\n      }\n    }, this)\n\n    if (unreached !== false) {\n      this.objectPath.splice(unreached)\n    }\n\n    return current\n  }\n\n  // Updates the keypath. This is called when any intermediary key is changed.\n  Observer.prototype.update = function() {\n    var next, oldValue\n\n    if ((next = this.realize()) !== this.target) {\n      if (isObject(this.target)) {\n        this.set(false, this.key, this.target, this.callback)\n      }\n\n      if (isObject(next)) {\n        this.set(true, this.key, next, this.callback)\n      }\n\n      oldValue = this.value()\n      this.target = next\n\n      if (this.value() !== oldValue) this.callback()\n    }\n  }\n\n  // Reads the current end value of the observed keypath. Returns undefined if\n  // the full keypath is unreachable.\n  Observer.prototype.value = function() {\n    if (isObject(this.target)) {\n      return this.get(this.key, this.target)\n    }\n  }\n\n  // Sets the current end value of the observed keypath. Calling setValue when\n  // the full keypath is unreachable is a no-op.\n  Observer.prototype.setValue = function(value) {\n    if (isObject(this.target)) {\n      this.adapter(this.key).set(this.target, this.key.path, value)\n    }\n  }\n\n  // Gets the provided key on an object.\n  Observer.prototype.get = function(key, obj) {\n    return this.adapter(key).get(obj, key.path)\n  }\n\n  // Observes or unobserves a callback on the object using the provided key.\n  Observer.prototype.set = function(active, key, obj, callback) {\n    var action = active ? 'observe' : 'unobserve'\n    this.adapter(key)[action](obj, key.path, callback)\n  }\n\n  // Returns an array of all unique adapter interfaces available.\n  Observer.prototype.interfaces = function() {\n    var interfaces = Object.keys(this.options.adapters)\n\n    Object.keys(sightglass.adapters).forEach(function(i) {\n      if (!~interfaces.indexOf(i)) {\n        interfaces.push(i)\n      }\n    })\n\n    return interfaces\n  }\n\n  // Convenience function to grab the adapter for a specific key.\n  Observer.prototype.adapter = function(key) {\n    return this.options.adapters[key.i] ||\n      sightglass.adapters[key.i]\n  }\n\n  // Unobserves the entire keypath.\n  Observer.prototype.unobserve = function() {\n    var obj\n\n    this.tokens.forEach(function(token, index) {\n      if (obj = this.objectPath[index]) {\n        this.set(false, token, obj, this.update)\n      }\n    }, this)\n\n    if (isObject(this.target)) {\n      this.set(false, this.key, this.target, this.callback)\n    }\n  }\n\n  // Check if a value is an object than can be observed.\n  function isObject(obj) {\n    return typeof obj === 'object' && obj !== null\n  }\n\n  // Error thrower.\n  function error(message) {\n    throw new Error('[sightglass] ' + message)\n  }\n\n  // Export module for Node and the browser.\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = sightglass\n  } else if (typeof define === 'function' && define.amd) {\n    define([], function() {\n      return this.sightglass = sightglass\n    })\n  } else {\n    this.sightglass = sightglass\n  }\n}).call(this);\n"],"sourceRoot":"/source/"}